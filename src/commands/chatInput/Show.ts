import {
  APIApplicationCommandInteractionDataBooleanOption,
  APIApplicationCommandInteractionDataIntegerOption,
  APIChatInputApplicationCommandInteraction,
  ApplicationCommandOptionType,
  ApplicationCommandType,
  MessageFlags,
} from '@discordjs/core';
import { discordClient, prisma } from '../../index.js';
import {
  ApplicationCommand,
  ApplicationCommandContextType,
  ApplicationIntegrationTypes,
  getUserFromInteraction,
} from '../../utils/CommandUtils.js';
import { getUserAvatarUrl, standardizeMessage } from '../../utils/MessageUtils.js';

export const showChatInputCommandData: ApplicationCommand = {
  name: 'show',
  description: 'Show a bookmark.',
  type: ApplicationCommandType.ChatInput,
  integration_types: [ApplicationIntegrationTypes.UserInstall],
  contexts: [ApplicationCommandContextType.BotDM, ApplicationCommandContextType.Guild, ApplicationCommandContextType.PrivateChannel],
  options: [
    {
      type: ApplicationCommandOptionType.Integer,
      name: 'id',
      description: 'Bookmark id',
      required: true,
      min_value: 1,
    },
    {
      type: ApplicationCommandOptionType.Boolean,
      name: 'show_others',
      description: 'Let others see the bookmark.',
      required: false,
    },
  ],
};

export async function showChatInputCommand(interaction: APIChatInputApplicationCommandInteraction) {
  // Get the options
  const bookmarkId = (
    interaction.data.options!.filter((opt) => opt.name.toLowerCase() === 'id')[0] as APIApplicationCommandInteractionDataIntegerOption
  ).value;
  const showOthers =
    (
      interaction.data.options!.filter(
        (opt) => opt.name.toLowerCase() === 'show_others',
      )[0] as APIApplicationCommandInteractionDataBooleanOption
    )?.value || false;
  // Defer the reply since it can take some time to process
  await discordClient.api.interactions.defer(interaction.id, interaction.token, {
    flags: !showOthers ? MessageFlags.Ephemeral : undefined,
  });
  const user = getUserFromInteraction(interaction);
  // Find the bookmark to show
  const foundBookmark = await prisma.bookmark.findFirst({
    where: {
      userId: BigInt(user.id),
      userBookmarkId: bookmarkId,
    },
    include: {
      tags: true,
    },
  });
  if (!foundBookmark) {
    await discordClient.api.interactions.editReply(interaction.application_id, interaction.token, {
      content: 'The bookmark requested does not exist.',
      flags: !showOthers ? MessageFlags.Ephemeral : undefined,
    });
    return;
  }
  // Get the message
  const foundMessage = await prisma.message.findFirst({
    where: {
      id: BigInt(foundBookmark.messageId),
    },
    include: {
      author: true,
    },
  });
  if (!foundMessage) {
    console.error('the message was not found for a bookmark');
    return;
  }
  const storedMessage = standardizeMessage(foundMessage.data!.toString(), Math.floor(foundMessage.updatedAt.getTime() / 1000));
  let footerText = `#${foundBookmark.userBookmarkId}`;
  const notAutogeneratedTags = foundBookmark.tags.filter((tag) => !tag.autogenerated).map((tag) => `#${tag.name}`);
  if (notAutogeneratedTags.length !== 0) {
    footerText += ` - ${notAutogeneratedTags.join(' ').substring(0, 1024)}`;
  }
  await discordClient.api.interactions.editReply(interaction.application_id, interaction.token, {
    content: `[Jump to message!](https://discord.com/channels/${storedMessage.guild_id || '@me'}/${storedMessage.channel_id}/${
      storedMessage.id
    })`,
    embeds: [
      {
        author: {
          name: `${foundMessage.author.username}${foundMessage.author.displayName ? ` (${foundMessage.author.displayName})` : ``}`,
          icon_url: getUserAvatarUrl(`${foundMessage.author.id}`, foundMessage.author.avatarHash),
        },
        description: storedMessage.content,
        timestamp: storedMessage.timestamp,
        footer: {
          text: footerText,
        },
      },
    ],
    flags: !showOthers ? MessageFlags.Ephemeral : undefined,
  });
}
